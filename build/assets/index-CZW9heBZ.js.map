{"version":3,"file":"index-CZW9heBZ.js","sources":["../../src/utils/logger.ts","../../src/services/routing.ts","../../src/services/configuration.ts","../../src/utils/url.ts","../../src/main.ts","../../src/app.ts"],"sourcesContent":["import type { LogEntry } from '@/types';\r\n\r\n/**\r\n * Simple logger utility for browser console logging\r\n * Follows the requirement to log all actions to browser console\r\n */\r\nexport class Logger {\r\n  private static instance: Logger;\r\n  private logs: LogEntry[] = [];\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): Logger {\r\n    if (!Logger.instance) {\r\n      Logger.instance = new Logger();\r\n    }\r\n    return Logger.instance;\r\n  }\r\n\r\n  private createLogEntry(level: LogEntry['level'], message: string, data?: Record<string, unknown>): LogEntry {\r\n    const entry: LogEntry = {\r\n      timestamp: new Date().toISOString(),\r\n      level,\r\n      message,\r\n    };\r\n    \r\n    if (data) {\r\n      entry.data = data;\r\n    }\r\n    \r\n    return entry;\r\n  }\r\n\r\n  public info(message: string, data?: Record<string, unknown>): void {\r\n    const entry = this.createLogEntry('info', message, data);\r\n    this.logs.push(entry);\r\n    // eslint-disable-next-line no-console\r\n    console.info(`[AKA-Service] ${entry.timestamp} - INFO: ${message}`, data || '');\r\n  }\r\n\r\n  public warn(message: string, data?: Record<string, unknown>): void {\r\n    const entry = this.createLogEntry('warn', message, data);\r\n    this.logs.push(entry);\r\n    // eslint-disable-next-line no-console\r\n    console.warn(`[AKA-Service] ${entry.timestamp} - WARN: ${message}`, data || '');\r\n  }\r\n\r\n  public error(message: string, data?: Record<string, unknown>): void {\r\n    const entry = this.createLogEntry('error', message, data);\r\n    this.logs.push(entry);\r\n    // eslint-disable-next-line no-console\r\n    console.error(`[AKA-Service] ${entry.timestamp} - ERROR: ${message}`, data || '');\r\n  }\r\n\r\n  public getLogs(): LogEntry[] {\r\n    return [...this.logs];\r\n  }\r\n\r\n  public clearLogs(): void {\r\n    this.logs = [];\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const logger = Logger.getInstance();\r\n","import type { RoutingConfiguration, RoutingGroup, Routing, URLParams, RedirectResult } from '@/types';\r\nimport { logger } from '@/utils/logger';\r\n\r\n/**\r\n * Core routing service that handles URL redirection logic\r\n * Implements the business rules defined in the requirements\r\n */\r\nexport class RoutingService {\r\n  private configuration: RoutingConfiguration | null = null;\r\n\r\n  /**\r\n   * Load routing configuration from a JSON object\r\n   * @param config The routing configuration\r\n   */\r\n  public loadConfiguration(config: RoutingConfiguration): void {\r\n    try {\r\n      this.validateConfiguration(config);\r\n      this.configuration = config;\r\n      logger.info('Routing configuration loaded successfully', {\r\n        groupCount: config.routingGroups.length,\r\n        version: config.version,\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      logger.error('Failed to load routing configuration', { error: message });\r\n      throw new Error(`Configuration loading failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find redirect target for given path and URL parameters\r\n   * @param path The relative path from the URL\r\n   * @param urlParams The URL parameters\r\n   * @returns Result containing redirect information\r\n   */\r\n  public findRedirect(path: string, urlParams: URLParams): RedirectResult {\r\n    logger.info('Processing redirect request', { path, urlParams });\r\n\r\n    if (!this.configuration) {\r\n      const error = 'No routing configuration loaded';\r\n      logger.error(error);\r\n      return { found: false, error };\r\n    }\r\n\r\n    try {\r\n      // Find matching routing group\r\n      const matchingGroup = this.findMatchingGroup(path, urlParams);\r\n      if (!matchingGroup) {\r\n        logger.warn('No matching routing group found', { path, urlParams });\r\n        return { found: false, error: 'No matching routing group found' };\r\n      }\r\n\r\n      // Find matching routing within the group\r\n      const matchingRouting = this.findMatchingRouting(matchingGroup, urlParams);\r\n      if (!matchingRouting) {\r\n        logger.warn('No matching routing found in group', {\r\n          groupName: matchingGroup.name,\r\n          urlParams,\r\n        });\r\n        return { found: false, error: 'No matching routing found' };\r\n      }\r\n\r\n      logger.info('Redirect target found', {\r\n        targetUrl: matchingRouting.redirectTarget,\r\n        groupName: matchingGroup.name,\r\n        routingName: matchingRouting.name,\r\n      });\r\n\r\n      return {\r\n        found: true,\r\n        targetUrl: matchingRouting.redirectTarget,\r\n        matchedGroup: matchingGroup.name,\r\n        matchedRouting: matchingRouting.name,\r\n      };\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      logger.error('Error during redirect processing', { error: message, path, urlParams });\r\n      return { found: false, error: `Processing error: ${message}` };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find a routing group that matches the path and URL parameters\r\n   */\r\n  private findMatchingGroup(path: string, urlParams: URLParams): RoutingGroup | null {\r\n    if (!this.configuration) {return null;}\r\n\r\n    for (const group of this.configuration.routingGroups) {\r\n      // Check if the group name matches the path\r\n      if (group.name.toLowerCase() !== path.toLowerCase()) {\r\n        continue;\r\n      }\r\n\r\n      // If group has dependency requirements, check them\r\n      if (group.dependsOnKey && group.dependsOnValue) {\r\n        const paramValue = urlParams[group.dependsOnKey];\r\n        if (paramValue !== group.dependsOnValue) {\r\n          logger.info('Group dependency not met', {\r\n            groupName: group.name,\r\n            requiredKey: group.dependsOnKey,\r\n            requiredValue: group.dependsOnValue,\r\n            actualValue: paramValue,\r\n          });\r\n          continue;\r\n        }\r\n      }\r\n\r\n      logger.info('Matching routing group found', { groupName: group.name });\r\n      return group;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Find a routing within a group that matches the URL parameters\r\n   */\r\n  private findMatchingRouting(group: RoutingGroup, urlParams: URLParams): Routing | null {\r\n    for (const routing of group.routings) {\r\n      // If routing has dependency requirements, check them\r\n      if (routing.dependsOnKey && routing.dependsOnValue) {\r\n        const paramValue = urlParams[routing.dependsOnKey];\r\n        if (paramValue !== routing.dependsOnValue) {\r\n          logger.info('Routing dependency not met', {\r\n            routingName: routing.name,\r\n            requiredKey: routing.dependsOnKey,\r\n            requiredValue: routing.dependsOnValue,\r\n            actualValue: paramValue,\r\n          });\r\n          continue;\r\n        }\r\n      }\r\n\r\n      logger.info('Matching routing found', { routingName: routing.name });\r\n      return routing;\r\n    }\r\n\r\n    // If no specific routing matched and there's only one routing without dependencies\r\n    if (group.routings.length === 1) {\r\n      const singleRouting = group.routings[0];\r\n      if (singleRouting && !singleRouting.dependsOnKey && !singleRouting.dependsOnValue) {\r\n        logger.info('Using default routing (no dependencies)', {\r\n          routingName: singleRouting.name,\r\n        });\r\n        return singleRouting;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Validate the routing configuration structure\r\n   */\r\n  private validateConfiguration(config: RoutingConfiguration): void {\r\n    if (!config) {\r\n      throw new Error('Configuration is null or undefined');\r\n    }\r\n\r\n    if (!config.version) {\r\n      throw new Error('Configuration version is required');\r\n    }\r\n\r\n    if (!Array.isArray(config.routingGroups)) {\r\n      throw new Error('routingGroups must be an array');\r\n    }\r\n\r\n    if (config.routingGroups.length === 0) {\r\n      throw new Error('At least one routing group is required');\r\n    }\r\n\r\n    // Validate each routing group\r\n    for (const group of config.routingGroups) {\r\n      this.validateRoutingGroup(group);\r\n    }\r\n\r\n    // Check for duplicate group names\r\n    const groupNames = config.routingGroups.map(g => g.name.toLowerCase());\r\n    const uniqueNames = new Set(groupNames);\r\n    if (groupNames.length !== uniqueNames.size) {\r\n      throw new Error('Duplicate routing group names found');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate a single routing group\r\n   */\r\n  private validateRoutingGroup(group: RoutingGroup): void {\r\n    if (!group.name || typeof group.name !== 'string') {\r\n      throw new Error('Routing group name is required and must be a string');\r\n    }\r\n\r\n    if (!Array.isArray(group.routings)) {\r\n      throw new Error('Group routings must be an array');\r\n    }\r\n\r\n    if (group.routings.length === 0) {\r\n      throw new Error(`Routing group '${group.name}' must have at least one routing`);\r\n    }\r\n\r\n    // Validate each routing in the group\r\n    for (const routing of group.routings) {\r\n      this.validateRouting(routing, group.name);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate a single routing\r\n   */\r\n  private validateRouting(routing: Routing, groupName: string): void {\r\n    if (!routing.name || typeof routing.name !== 'string') {\r\n      throw new Error(`Routing name is required in group '${groupName}'`);\r\n    }\r\n\r\n    if (!routing.redirectTarget || typeof routing.redirectTarget !== 'string') {\r\n      throw new Error(`Redirect target is required for routing '${routing.name}' in group '${groupName}'`);\r\n    }\r\n\r\n    // Basic URL validation for redirect target\r\n    try {\r\n      new URL(routing.redirectTarget);\r\n    } catch {\r\n      throw new Error(`Invalid redirect target URL '${routing.redirectTarget}' in routing '${routing.name}'`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  public getConfiguration(): RoutingConfiguration | null {\r\n    return this.configuration;\r\n  }\r\n\r\n  /**\r\n   * Check if configuration is loaded\r\n   */\r\n  public isConfigurationLoaded(): boolean {\r\n    return this.configuration !== null;\r\n  }\r\n}\r\n","import type { RoutingConfiguration } from '@/types';\r\nimport { logger } from '@/utils/logger';\r\n\r\n/**\r\n * Service for loading and managing routing configuration\r\n * Handles both local and remote configuration sources\r\n */\r\nexport class ConfigurationService {\r\n  private static instance: ConfigurationService;\r\n  private configCache: RoutingConfiguration | null = null;\r\n  private lastLoaded: Date | null = null;\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): ConfigurationService {\r\n    if (!ConfigurationService.instance) {\r\n      ConfigurationService.instance = new ConfigurationService();\r\n    }\r\n    return ConfigurationService.instance;\r\n  }\r\n\r\n  /**\r\n   * Load configuration from a file path\r\n   * @param configPath Path to the configuration file\r\n   * @returns Promise resolving to the configuration\r\n   */\r\n  public async loadFromFile(configPath: string): Promise<RoutingConfiguration> {\r\n    try {\r\n      logger.info('Loading configuration from file', { configPath });\r\n      \r\n      const response = await fetch(configPath);\r\n      if (!response.ok) {\r\n        throw new Error(`Failed to fetch configuration: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const config = (await response.json()) as RoutingConfiguration;\r\n      this.configCache = config;\r\n      this.lastLoaded = new Date();\r\n\r\n      logger.info('Configuration loaded successfully from file', {\r\n        configPath,\r\n        version: config.version,\r\n        groupCount: config.routingGroups.length,\r\n      });\r\n\r\n      return config;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      logger.error('Failed to load configuration from file', { configPath, error: message });\r\n      throw new Error(`Configuration loading failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Load configuration from a direct object\r\n   * @param config The configuration object\r\n   * @returns The validated configuration\r\n   */\r\n  public loadFromObject(config: RoutingConfiguration): RoutingConfiguration {\r\n    try {\r\n      logger.info('Loading configuration from object', {\r\n        version: config.version,\r\n        groupCount: config.routingGroups.length,\r\n      });\r\n\r\n      // Validate the configuration\r\n      this.validateConfiguration(config);\r\n      \r\n      this.configCache = config;\r\n      this.lastLoaded = new Date();\r\n\r\n      logger.info('Configuration loaded successfully from object');\r\n      return config;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      logger.error('Failed to load configuration from object', { error: message });\r\n      throw new Error(`Configuration loading failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get cached configuration\r\n   * @returns Cached configuration or null if not loaded\r\n   */\r\n  public getConfiguration(): RoutingConfiguration | null {\r\n    return this.configCache;\r\n  }\r\n\r\n  /**\r\n   * Check if configuration is loaded and valid\r\n   * @returns True if configuration is available\r\n   */\r\n  public isConfigurationAvailable(): boolean {\r\n    return this.configCache !== null;\r\n  }\r\n\r\n  /**\r\n   * Get information about when configuration was last loaded\r\n   * @returns Date of last load or null if never loaded\r\n   */\r\n  public getLastLoaded(): Date | null {\r\n    return this.lastLoaded;\r\n  }\r\n\r\n  /**\r\n   * Clear cached configuration\r\n   */\r\n  public clearCache(): void {\r\n    this.configCache = null;\r\n    this.lastLoaded = null;\r\n    logger.info('Configuration cache cleared');\r\n  }\r\n\r\n  /**\r\n   * Reload configuration from the same source\r\n   * Note: This requires storing the source information\r\n   */\r\n  public async reloadConfiguration(): Promise<RoutingConfiguration | null> {\r\n    if (!this.configCache) {\r\n      logger.warn('No configuration to reload');\r\n      return null;\r\n    }\r\n\r\n    // For now, just return the cached configuration\r\n    // In a real implementation, you'd store the source and reload from it\r\n    logger.info('Configuration reload requested (returning cached version)');\r\n    return this.configCache;\r\n  }\r\n\r\n  /**\r\n   * Validate configuration structure\r\n   * @param config Configuration to validate\r\n   * @throws Error if configuration is invalid\r\n   */\r\n  private validateConfiguration(config: unknown): RoutingConfiguration {\r\n    if (!config || typeof config !== 'object') {\r\n      throw new Error('Configuration must be a valid object');\r\n    }\r\n\r\n    const typedConfig = config as Record<string, unknown>;\r\n\r\n    if (!typedConfig.version || typeof typedConfig.version !== 'string') {\r\n      throw new Error('Configuration version is required and must be a string');\r\n    }\r\n\r\n    if (!Array.isArray(typedConfig.routingGroups)) {\r\n      throw new Error('routingGroups must be an array');\r\n    }\r\n\r\n    return config as RoutingConfiguration;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const configurationService = ConfigurationService.getInstance();\r\n","import type { URLParams } from '@/types';\r\n\r\n/**\r\n * Utility functions for URL parsing and manipulation\r\n */\r\nexport class URLUtils {\r\n  /**\r\n   * Parse URL parameters from a query string\r\n   * @param search The search part of the URL (e.g., '?param1=value1&param2=value2')\r\n   * @returns Object with parsed parameters\r\n   */\r\n  public static parseURLParams(search: string): URLParams {\r\n    const params: URLParams = {};\r\n    \r\n    if (!search || search.length <= 1) {\r\n      return params;\r\n    }\r\n\r\n    // Remove the leading '?' if present\r\n    const queryString = search.startsWith('?') ? search.slice(1) : search;\r\n    \r\n    // Split by '&' and process each parameter\r\n    queryString.split('&').forEach(param => {\r\n      const [key, ...valueParts] = param.split('=');\r\n      if (key) {\r\n        // Join value parts back together in case the value contained '='\r\n        const value = valueParts.join('=');\r\n        params[decodeURIComponent(key)] = value ? decodeURIComponent(value) : '';\r\n      }\r\n    });\r\n\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Extract the path from a URL (without query parameters)\r\n   * @param url The full URL or pathname\r\n   * @returns The path part without leading slash\r\n   */\r\n  public static extractPath(url: string): string {\r\n    try {\r\n      // Handle both full URLs and pathnames\r\n      let pathname: string;\r\n      \r\n      if (url.startsWith('http://') || url.startsWith('https://')) {\r\n        const urlObj = new URL(url);\r\n        pathname = urlObj.pathname;\r\n      } else {\r\n        pathname = url.split('?')[0] || '';\r\n      }\r\n\r\n      // Remove leading slash and return\r\n      return pathname.startsWith('/') ? pathname.slice(1) : pathname;\r\n    } catch {\r\n      // Fallback for invalid URLs\r\n      const path = url.split('?')[0] || '';\r\n      return path.startsWith('/') ? path.slice(1) : path;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate if a URL is properly formatted\r\n   * @param url The URL to validate\r\n   * @returns True if valid, false otherwise\r\n   */\r\n  public static isValidURL(url: string): boolean {\r\n    try {\r\n      new URL(url);\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Ensure a URL has a protocol\r\n   * @param url The URL to check\r\n   * @returns URL with protocol, defaults to https://\r\n   */\r\n  public static ensureProtocol(url: string): string {\r\n    if (url.startsWith('http://') || url.startsWith('https://')) {\r\n      return url;\r\n    }\r\n    return `https://${url}`;\r\n  }\r\n}\r\n","import { RoutingService } from '@/services/routing';\r\nimport { configurationService } from '@/services/configuration';\r\nimport { URLUtils } from '@/utils/url';\r\nimport { logger } from '@/utils/logger';\r\nimport type { RoutingConfiguration } from '@/types';\r\n\r\n/**\r\n * Main application class for the AKA URL Shortener Service\r\n * Handles initialization, routing, and redirection logic\r\n */\r\nexport class AKAService {\r\n  private routingService: RoutingService;\r\n  private isInitialized = false;\r\n\r\n  constructor() {\r\n    this.routingService = new RoutingService();\r\n  }\r\n\r\n  /**\r\n   * Initialize the service with configuration\r\n   * @param configPath Path to configuration file or configuration object\r\n   */\r\n  public async initialize(configPath: string | RoutingConfiguration): Promise<void> {\r\n    try {\r\n      logger.info('Initializing AKA Service', { configPath: typeof configPath });\r\n\r\n      let config: RoutingConfiguration;\r\n\r\n      if (typeof configPath === 'string') {\r\n        config = await configurationService.loadFromFile(configPath);\r\n      } else {\r\n        config = configurationService.loadFromObject(configPath);\r\n      }\r\n\r\n      this.routingService.loadConfiguration(config);\r\n      this.isInitialized = true;\r\n\r\n      logger.info('AKA Service initialized successfully', {\r\n        groupCount: config.routingGroups.length,\r\n        version: config.version,\r\n      });\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      logger.error('Failed to initialize AKA Service', { error: message });\r\n      throw new Error(`Service initialization failed: ${message}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Process a redirect request\r\n   * @param url The full URL or pathname with query parameters\r\n   * @returns Redirect result or throws error\r\n   */\r\n  public processRedirect(url: string): string {\r\n    if (!this.isInitialized) {\r\n      throw new Error('Service not initialized. Call initialize() first.');\r\n    }\r\n\r\n    try {\r\n      logger.info('Processing redirect request', { url });\r\n\r\n      // Parse the URL\r\n      const path = URLUtils.extractPath(url);\r\n      const urlObj = new URL(url, 'https://example.com'); // Use dummy base for relative URLs\r\n      const urlParams = URLUtils.parseURLParams(urlObj.search);\r\n\r\n      logger.info('Parsed URL components', { path, urlParams });\r\n\r\n      // Find redirect target\r\n      const result = this.routingService.findRedirect(path, urlParams);\r\n\r\n      if (!result.found || !result.targetUrl) {\r\n        const error = result.error || 'No redirect target found';\r\n        logger.warn('Redirect not found', { path, urlParams, error });\r\n        throw new Error(error);\r\n      }\r\n\r\n      logger.info('Redirect target found', {\r\n        targetUrl: result.targetUrl,\r\n        matchedGroup: result.matchedGroup,\r\n        matchedRouting: result.matchedRouting,\r\n      });\r\n\r\n      return result.targetUrl;\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      logger.error('Error processing redirect', { error: message, url });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get service status and configuration info\r\n   */\r\n  public getStatus(): {\r\n    initialized: boolean;\r\n    configLoaded: boolean;\r\n    configVersion?: string;\r\n    groupCount?: number;\r\n    lastConfigLoad?: Date;\r\n  } {\r\n    const config = configurationService.getConfiguration();\r\n    const status: {\r\n      initialized: boolean;\r\n      configLoaded: boolean;\r\n      configVersion?: string;\r\n      groupCount?: number;\r\n      lastConfigLoad?: Date;\r\n    } = {\r\n      initialized: this.isInitialized,\r\n      configLoaded: config !== null,\r\n    };\r\n\r\n    if (config) {\r\n      status.configVersion = config.version;\r\n      status.groupCount = config.routingGroups.length;\r\n    }\r\n\r\n    const lastLoad = configurationService.getLastLoaded();\r\n    if (lastLoad) {\r\n      status.lastConfigLoad = lastLoad;\r\n    }\r\n\r\n    return status;\r\n  }\r\n\r\n  /**\r\n   * Reload configuration\r\n   */\r\n  public async reloadConfiguration(): Promise<void> {\r\n    try {\r\n      logger.info('Reloading configuration');\r\n      const config = await configurationService.reloadConfiguration();\r\n      if (config) {\r\n        this.routingService.loadConfiguration(config);\r\n        logger.info('Configuration reloaded successfully');\r\n      }\r\n    } catch (error) {\r\n      const message = error instanceof Error ? error.message : 'Unknown error';\r\n      logger.error('Failed to reload configuration', { error: message });\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const akaService = new AKAService();\r\n","import { akaService } from '@/main';\r\nimport { logger } from '@/utils/logger';\r\n\r\n/**\r\n * Frontend application for the AKA URL Shortener Service\r\n * Handles UI interactions and provides testing interface\r\n */\r\n\r\n// Global variables for UI elements\r\nlet serviceStatusEl: HTMLElement | null = null;\r\nlet configStatusEl: HTMLElement | null = null;\r\nlet groupCountEl: HTMLElement | null = null;\r\nlet configVersionEl: HTMLElement | null = null;\r\nlet lastUpdatedEl: HTMLElement | null = null;\r\nlet testUrlInput: HTMLInputElement | null = null;\r\nlet testResultEl: HTMLElement | null = null;\r\n\r\n/**\r\n * Initialize the application\r\n */\r\nasync function initializeApp(): Promise<void> {\r\n  try {\r\n    logger.info('Initializing AKA Service application');\r\n    \r\n    // Check if hide=true parameter is present\r\n    const urlParams = new URLSearchParams(window.location.search);\r\n    const hideUI = urlParams.get('hide') === 'true';\r\n    \r\n    if (hideUI) {\r\n      // Hide UI mode - show only white screen and perform redirect\r\n      document.body.innerHTML = '<div style=\"background: white; width: 100vw; height: 100vh;\"></div>';\r\n      document.body.style.background = 'white';\r\n      document.body.style.margin = '0';\r\n      document.body.style.padding = '0';\r\n      \r\n      // Initialize service for redirect processing\r\n      await akaService.initialize('/config.json');\r\n      \r\n      // Perform redirect immediately\r\n      handleDirectRedirectHidden();\r\n      return;\r\n    }\r\n    \r\n    // Get DOM elements for normal UI mode\r\n    serviceStatusEl = document.getElementById('service-status');\r\n    configStatusEl = document.getElementById('config-status');\r\n    groupCountEl = document.getElementById('group-count');\r\n    configVersionEl = document.getElementById('config-version');\r\n    lastUpdatedEl = document.getElementById('last-updated');\r\n    testUrlInput = document.getElementById('test-url') as HTMLInputElement;\r\n    testResultEl = document.getElementById('test-result');\r\n\r\n    // Initialize the service with configuration\r\n    await akaService.initialize('/config.json');\r\n    \r\n    // Update UI with service status\r\n    updateServiceStatus();\r\n    \r\n    // Set up URL handling for direct redirects\r\n    handleDirectRedirect();\r\n    \r\n    logger.info('Application initialized successfully');\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Unknown error';\r\n    logger.error('Failed to initialize application', { error: message });\r\n    updateStatusError('Failed to initialize service: ' + message);\r\n  }\r\n}\r\n\r\n/**\r\n * Update service status in the UI\r\n */\r\nfunction updateServiceStatus(): void {\r\n  try {\r\n    const status = akaService.getStatus();\r\n    \r\n    if (serviceStatusEl) {\r\n      serviceStatusEl.textContent = status.initialized ? 'Active' : 'Inactive';\r\n      serviceStatusEl.style.color = status.initialized ? '#28a745' : '#dc3545';\r\n    }\r\n    \r\n    if (configStatusEl) {\r\n      configStatusEl.textContent = status.configLoaded ? 'Loaded' : 'Not Loaded';\r\n      configStatusEl.style.color = status.configLoaded ? '#28a745' : '#dc3545';\r\n    }\r\n    \r\n    if (groupCountEl && status.groupCount !== undefined) {\r\n      groupCountEl.textContent = status.groupCount.toString();\r\n    }\r\n    \r\n    if (configVersionEl && status.configVersion) {\r\n      configVersionEl.textContent = status.configVersion;\r\n    }\r\n    \r\n    if (lastUpdatedEl && status.lastConfigLoad) {\r\n      lastUpdatedEl.textContent = status.lastConfigLoad.toLocaleString();\r\n    }\r\n    \r\n    logger.info('Service status updated', status);\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Unknown error';\r\n    logger.error('Failed to update service status', { error: message });\r\n  }\r\n}\r\n\r\n/**\r\n * Update status with error message\r\n */\r\nfunction updateStatusError(message: string): void {\r\n  if (serviceStatusEl) {\r\n    serviceStatusEl.textContent = 'Error';\r\n    serviceStatusEl.style.color = '#dc3545';\r\n  }\r\n  \r\n  if (configStatusEl) {\r\n    configStatusEl.textContent = message;\r\n    configStatusEl.style.color = '#dc3545';\r\n  }\r\n}\r\n\r\n/**\r\n * Handle direct redirect for incoming URLs\r\n */\r\nfunction handleDirectRedirect(): void {\r\n  // Check if this is a redirect request (not the main page)\r\n  const currentPath = window.location.pathname;\r\n  const currentSearch = window.location.search;\r\n  \r\n  // Skip redirect for root path and admin paths\r\n  if (currentPath === '/' || currentPath === '/index.html' || currentPath.startsWith('/admin')) {\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    logger.info('Processing direct redirect request', { \r\n      path: currentPath, \r\n      search: currentSearch \r\n    });\r\n    \r\n    const fullUrl = currentPath + currentSearch;\r\n    const redirectTarget = akaService.processRedirect(fullUrl);\r\n    \r\n    logger.info('Redirecting to target URL', { \r\n      sourceUrl: fullUrl, \r\n      targetUrl: redirectTarget \r\n    });\r\n    \r\n    // Perform the redirect\r\n    window.location.href = redirectTarget;\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Unknown error';\r\n    logger.error('Direct redirect failed', { \r\n      error: message, \r\n      path: currentPath, \r\n      search: currentSearch \r\n    });\r\n    \r\n    // Show error page or redirect to home\r\n    showRedirectError(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Handle direct redirect for hidden UI mode\r\n */\r\nfunction handleDirectRedirectHidden(): void {\r\n  // Get current URL without the hide parameter\r\n  const currentPath = window.location.pathname;\r\n  const currentSearch = window.location.search;\r\n  \r\n  try {\r\n    // Remove hide parameter from the URL for processing\r\n    const urlParams = new URLSearchParams(currentSearch);\r\n    urlParams.delete('hide');\r\n    const cleanSearch = urlParams.toString();\r\n    const cleanUrl = currentPath + (cleanSearch ? '?' + cleanSearch : '');\r\n    \r\n    logger.info('Processing hidden redirect request', { \r\n      path: currentPath, \r\n      search: cleanSearch \r\n    });\r\n    \r\n    // For root path, try to redirect based on remaining parameters\r\n    if (currentPath === '/' || currentPath === '/index.html') {\r\n      if (cleanSearch) {\r\n        // If there are parameters, try to find a matching route\r\n        const redirectTarget = akaService.processRedirect('/' + cleanSearch);\r\n        logger.info('Redirecting from root with parameters', { \r\n          sourceUrl: cleanUrl, \r\n          targetUrl: redirectTarget \r\n        });\r\n        window.location.href = redirectTarget;\r\n      } else {\r\n        // No parameters, show white screen indefinitely\r\n        logger.info('No redirect target found for root path without parameters');\r\n      }\r\n    } else {\r\n      // Process redirect for non-root paths\r\n      const redirectTarget = akaService.processRedirect(cleanUrl);\r\n      logger.info('Redirecting to target URL', { \r\n        sourceUrl: cleanUrl, \r\n        targetUrl: redirectTarget \r\n      });\r\n      window.location.href = redirectTarget;\r\n    }\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Unknown error';\r\n    logger.error('Hidden redirect failed', { \r\n      error: message, \r\n      path: currentPath, \r\n      search: currentSearch \r\n    });\r\n    \r\n    // In hidden mode, just show white screen on error\r\n    // Optionally, redirect to a fallback URL after a delay\r\n    setTimeout(() => {\r\n      if (window.location.pathname === '/') {\r\n        // Stay on white screen for root errors\r\n        logger.info('Staying on white screen due to redirect error');\r\n      }\r\n    }, 1000);\r\n  }\r\n}\r\n\r\n/**\r\n * Show redirect error\r\n */\r\nfunction showRedirectError(message: string): void {\r\n  document.body.innerHTML = `\r\n    <div style=\"\r\n      font-family: 'Segoe UI', sans-serif;\r\n      max-width: 600px;\r\n      margin: 2rem auto;\r\n      padding: 2rem;\r\n      text-align: center;\r\n      background: #f8f9fa;\r\n      border-radius: 10px;\r\n      border-left: 4px solid #dc3545;\r\n    \">\r\n      <h1 style=\"color: #dc3545; margin-bottom: 1rem;\">Redirect Error</h1>\r\n      <p style=\"color: #666; margin-bottom: 1rem;\">The requested URL could not be redirected:</p>\r\n      <p style=\"\r\n        background: #fff;\r\n        padding: 1rem;\r\n        border-radius: 5px;\r\n        font-family: monospace;\r\n        color: #dc3545;\r\n        border: 1px solid #f5c6cb;\r\n      \">${message}</p>\r\n      <button onclick=\"window.location.href='/'\" style=\"\r\n        background: #007bff;\r\n        color: white;\r\n        padding: 0.75rem 1.5rem;\r\n        border: none;\r\n        border-radius: 5px;\r\n        cursor: pointer;\r\n        margin-top: 1rem;\r\n      \">Go to Home Page</button>\r\n    </div>\r\n  `;\r\n}\r\n\r\n/**\r\n * Test redirect functionality\r\n */\r\nfunction testRedirect(): void {\r\n  if (!testUrlInput || !testResultEl) {\r\n    logger.error('Test UI elements not found');\r\n    return;\r\n  }\r\n  \r\n  const testUrl = testUrlInput.value.trim();\r\n  if (!testUrl) {\r\n    showTestResult('Please enter a URL to test', 'error');\r\n    return;\r\n  }\r\n  \r\n  try {\r\n    logger.info('Testing redirect for URL', { testUrl });\r\n    \r\n    const redirectTarget = akaService.processRedirect(testUrl);\r\n    \r\n    showTestResult(`\r\n      <strong>✅ Redirect Found!</strong><br>\r\n      <strong>Source:</strong> ${testUrl}<br>\r\n      <strong>Target:</strong> <a href=\"${redirectTarget}\" target=\"_blank\">${redirectTarget}</a><br>\r\n      <small>Click the link to test the redirect in a new tab</small>\r\n    `, 'success');\r\n    \r\n    logger.info('Test redirect successful', { testUrl, redirectTarget });\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : 'Unknown error';\r\n    showTestResult(`\r\n      <strong>❌ Redirect Failed</strong><br>\r\n      <strong>URL:</strong> ${testUrl}<br>\r\n      <strong>Error:</strong> ${message}\r\n    `, 'error');\r\n    \r\n    logger.warn('Test redirect failed', { testUrl, error: message });\r\n  }\r\n}\r\n\r\n/**\r\n * Show test result in UI\r\n */\r\nfunction showTestResult(message: string, type: 'success' | 'error'): void {\r\n  if (!testResultEl) {return;}\r\n  \r\n  testResultEl.innerHTML = `<div class=\"result ${type}\">${message}</div>`;\r\n}\r\n\r\n/**\r\n * Clear test result\r\n */\r\nfunction clearResult(): void {\r\n  if (testResultEl) {\r\n    testResultEl.innerHTML = '';\r\n  }\r\n  if (testUrlInput) {\r\n    testUrlInput.value = '';\r\n  }\r\n}\r\n\r\n/**\r\n * Set test URL in input field\r\n */\r\nfunction setTestUrl(url: string): void {\r\n  if (testUrlInput) {\r\n    testUrlInput.value = url;\r\n  }\r\n}\r\n\r\n// Extend Window interface for global functions\r\ndeclare global {\r\n  interface Window {\r\n    testRedirect: () => void;\r\n    clearResult: () => void;\r\n    setTestUrl: (url: string) => void;\r\n  }\r\n}\r\n\r\n// Make functions available globally for HTML onclick handlers\r\nwindow.testRedirect = testRedirect;\r\nwindow.clearResult = clearResult;\r\nwindow.setTestUrl = setTestUrl;\r\n\r\n// Initialize the application when DOM is loaded\r\ndocument.addEventListener('DOMContentLoaded', initializeApp);\r\n\r\n// Handle browser back/forward navigation\r\nwindow.addEventListener('popstate', handleDirectRedirect);\r\n"],"names":["Logger","static","logs","constructor","getInstance","instance","createLogEntry","level","message","data","entry","timestamp","Date","toISOString","info","this","push","console","warn","error","getLogs","clearLogs","logger","RoutingService","configuration","loadConfiguration","config","validateConfiguration","groupCount","routingGroups","length","version","Error","findRedirect","path","urlParams","found","matchingGroup","findMatchingGroup","matchingRouting","findMatchingRouting","targetUrl","redirectTarget","groupName","name","routingName","matchedGroup","matchedRouting","group","toLowerCase","dependsOnKey","dependsOnValue","paramValue","requiredKey","requiredValue","actualValue","routing","routings","singleRouting","Array","isArray","validateRoutingGroup","groupNames","map","g","uniqueNames","Set","size","validateRouting","URL","getConfiguration","isConfigurationLoaded","ConfigurationService","configCache","lastLoaded","loadFromFile","configPath","response","fetch","ok","status","statusText","json","loadFromObject","isConfigurationAvailable","getLastLoaded","clearCache","reloadConfiguration","typedConfig","configurationService","URLUtils","parseURLParams","search","params","startsWith","slice","split","forEach","param","key","valueParts","value","join","decodeURIComponent","extractPath","url","pathname","isValidURL","ensureProtocol","akaService","routingService","isInitialized","initialize","processRedirect","urlObj","result","getStatus","initialized","configLoaded","configVersion","lastLoad","lastConfigLoad","serviceStatusEl","configStatusEl","groupCountEl","configVersionEl","lastUpdatedEl","testUrlInput","testResultEl","handleDirectRedirect","currentPath","window","location","currentSearch","fullUrl","sourceUrl","href","document","body","innerHTML","showRedirectError","showTestResult","type","testRedirect","testUrl","trim","clearResult","setTestUrl","addEventListener","async","URLSearchParams","get","style","background","margin","padding","delete","cleanSearch","toString","cleanUrl","setTimeout","handleDirectRedirectHidden","getElementById","textContent","color","toLocaleString","updateServiceStatus","updateStatusError"],"mappings":"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"}